# 一、垃圾回收算法

## 1、标记清除

#### 	1.1 描述

​			首先通过Root节点,找到对应的所有可达的那些对象,将其打上标记,表示这些对象正在被使用,无需回收

​			其次再通过一次扫描,将没有打上标记的对象回收

#### 	1.2 优点

​			针对于不是很频繁回收的对象,比较高效

#### 	1.3 缺点

​			1、容易产生碎片导数空间使用率不高

​			2、实际上扫描了两次

## 2、复制算法

### 	2.1 描述

​			实际上就是将内存空间拆分成为两部分,再扫描对象是否可用的过程中, 直接将对象放到另外一半的内存空间中,对象迁移完成以后,将原有的这一半内存空间全部释放.

### 	2.2 优点

​			1、存活对象比较短的时候,效率比较高

​			2、只需要进行一次的扫描过程即可

### 	2.3 缺点

​			1、因为复制的原因, 导致对象只能存放到一半的内存空间中

​			2、需要进行移动对象位置

## 3、标记整理

### 	3.1 描述

​			首先也需要从根节点开始对所有可达对象做一次标记，然后将所有的存活对象按照顺序摆放到内存开始的地方。最后清理整理好对象结尾往后的所有空间。

### 	3.2 优点

​			这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

### 	3.3 缺点

​			1、相对来说,比标记-清除算法比较耗时

​			2、同时整理也是一个比较复杂的事情,增加了处理的复杂性

# 二、垃圾回收器

## 	2.1、串行GC(Serial GC )/ ParNewGC

​			串行的垃圾回收器, 顾名思义,就是一个接着一个搞,我没回收完垃圾, 谁也不能动.

​			使用-XX：+UseSerialGC开启串行GC.

​			ParNewGC是Serial GC的改进版本,可以同CMS配合使用.

​			Serial 是新生代收集器,使用的是复制算法.

​			SerialOld 是老年代收集器,使用的是标记-整理算法.

​			ParNew 是新生代的收集器,依旧采用的是复制算法.

​			ParNew 与Serial 最大的区别就是增加了并发的操作, jvm可以开启多个gc的线程进行垃圾回收

## 	2.2、**并行** GC(Parallel GC）

​			并行垃圾回收器. jdk1.8 1.7等默认的来记回收器

​			通过“-XX：+UseParallelGC”、”-XX：+UseParallelOldGC“或“-XX：+UseParallelGC -XX:+UseParallelOldGC”开启并行垃圾回收器

​			再垃圾回收过程中,jvm会调用多个线程来同时进行垃圾回收,这样使回收的时间更短

​			并行GC是成对出现的,其中包括了

​				1、并行年轻代的垃圾回收器(ParallelScavenge)

​						其被称之为吞吐量优先收集器.

​						使用复制算法

​				2、并行老年带的垃圾回收器(ParallelOld)

​						使用标记-清除-整理

## 	2.3、CMS GC

​				CMS属于一款老年代的垃圾回收器.设计的初衷是为了避免老年代在垃圾回收过程中长时间的卡顿.

​				它是对于响应时间的重要性需求大于吞吐量要求的收集器。对于要求服务器响应速度高的情况下，使用CMS非常合适。

​				1、不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。

​				2、在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。

​				CMS的六个阶段

​					阶段 1: Initial Mark（初始标记）--STW

​					阶段 2: Concurrent Mark（并发标记）

​					阶段 3: Concurrent Preclean（并发预清理）

​					阶段 4: Final Remark（最终标记）-- STW

​					阶段 5: Concurrent Sweep（并发清除）

​					阶段 6: Concurrent Reset（并发重置）

## 	2.4、G1 GC

### 		处理步骤

​				1、年轻代模式转移暂停（Evacuation Pause）

​						G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。

​				2、并发标记（Concurrent Marking）

​					实际上是借鉴了CMS的是实现方式, 同样有几个步骤,分别为:

​						**阶段** **1: Initial Mark**（初始标记）

​							此阶段标记所有从 GC 根对象直接可达的对象。

​						**阶段** **2: Root Region Scan**（Root区扫描）

​							此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。

​						**阶段** **3: Concurrent Mark**（并发标记）

​							此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。

​						**阶段** **4: Remark**（再次标记）

​							和 CMS 类似，这是一次 STW 停顿(因为不是并发的阶段)，以完成标记过程。 G1 收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。

​						**阶段** **5: Cleanup**（清理）

​				3、转移暂停: 混合模式（Evacuation Pause (mixed)）

​						并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。

​						因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。混合收集的过程，很大程度上和前面的 fully-young gc 是一样的。						

### 		注意事项

​				特别需要注意的是，某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的。

​				1.并发模式失败

​					G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小， 或者调整周期（例如增加线程数-XX：ConcGCThreads 等）。

​				2.晋升失败

​					没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC(to-space exhausted/to-space overflow）。

​					**解决办法：**

​						a) 增加 –XX：G1ReservePercent 选项的值（并相应增加总的堆大小）增加预留内存量。

​						b) 通过减少 –XX：InitiatingHeapOccupancyPercent 提前启动标记周期。

​						c) 也可以通过增加 –XX：ConcGCThreads 选项的值来增加并行标记线程的数目。

​				3.巨型对象分配失败

​						当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间。

​					**解决办法**：增加内存或者增大 -XX：G1HeapRegionSize